# nginx async eventDriven 정리
참고자료 : https://www.nginx.com/blog/thread-pools-boost-performance-9x/](https://www.nginx.com/blog/thread-pools-boost-performance-9x/

 

일반적으로 nginx는 연결에서 발생하는 모든 이벤트에 대한 정보를 커널로 부터 수신한 다음 운영 체제에 무엇을 해야 하는지에 대한 명령을 제공하는 컨트롤러이자 이벤트 핸들러이다. 사실, 운영체제가 하는 일은 바이트를 읽고 쓰는 일상적인 일인데 반해, nginx는 운영체제를 조율하므로써 모든 힘든 작업을 수행한다. 따라서 적시에 빠르게 대응하는 것이 매우 중요하다.

nginx는 여러 이벤트가 들어왔을 때 하나하나씩 수행한다. 모든 프로세스는 하나의 스레드에서 간단한 루프를 돌며 처리된다. nginx는 이벤트큐에서 데큐하여 이벤트를 가져오고 해당 요청에 대한 처리를 진행한다.

그런데 만약 엄청 무거운 요청이 발생하면 해당 요청이 끝날 때까지 모든 요청이 사이클이 중지될 것이다. 이 동안에 worker 스레드는 다른 이벤트들을 처리할 리소스가 충분함에도 불구하고 기다려야 할 지도 모른다. 이를 해결하기 위해 nginx에서는 thread pool을 사용한다.

thread pool은 배달 서비스와 유사하다. I/O를 수행해야 하는 요청이 있을 경우 해당 요청을 넘겨받은 스레드는 본인이 직접 처리하지 않고 thread pool에 있는 tasks queue에 집어넣는다. 집어넣고 나서 해당 task가 끝날 때까지 기다리지 않고 다시 event cycle을 돌면서 다른 요청을 처리한다. 다른 요청을 처리하는 동안 thread pool에 있는 free상태의 thread가 해당 I/O요청을 수행하고, 수행이 완료되면 worker process에게 완료되었다는 사실을 알려준다.

그러나 이러한 방식이 완벽한 방식은 아니다. 또한 thread pool은 nginx 실행시 default로 적용되는 것도 아니다. 내가 봤을 때 thread pool이 async 방식을 가장 잘 나타내는 것 같은데...

event driven은 이벤트가 발생했을 때 프로세스를 생성하지 않고 일정 수의 워커 프로세스를 미리 생성해두고 해당 프로세스가 가지고 있는 event queue에 event를 집어넣는다고 해서 event인 것 같다. 

비동기는 클라이언트로 부터 들어온 요청에 대해 대응되는 프로세스가 담당하지 않고 워커 프로세스의 event queue에 요청들이 쌓이고, 워크 프로세스가 dequeue하면서 요청을 하나씩 처리한다는 점에서 비동기인 것 같다. 즉, 요청을 받아들이고 처리하는 시점이 동일하지 않기 때문에 비동기라고 말할 수 있다. dart에서 I/O작업을 수행하는 future 함수를 처리할 때, future 함수 앞단에 async 키워드를 둬서 다른 코드들을 전부 수행하고, future 함수로 부터 미래에 응답이 들어왔을 때 다시 처리하는 것과 유사한 것 같다.
