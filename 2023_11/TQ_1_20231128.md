## 인터페이스는 어떻게 Object 클래스의 메소드를 사용?

답변 :  인터페이스가 extends한 상위 인터페이스가 없을 경우(pure interface), 암묵적으로 Object에 있는 각각의 메소드들이 해당 인터페이스에 선언된다. 덕분에, 인터페이스는 Object 클래스를 상속받지 않더라도(상속도 불가능 하겠지만) Object 클래스의 메소드를 사용할 수 있는 것이다.

> *If an interface has no direct superinterfaces, then the interface implicitly declares a `public` `abstract` member method `m` with signature s, return type r, and `throws` clause t corresponding to each `public` instance method `m` with signature s, return type r, and `throws` clause t declared in `Object`, unless an `abstract` method with the same signature, same return type, and a compatible `throws` clause is explicitly declared by the interface. - JLS 9.2*
>

<br><br><br>

## java.lang 패키지는 뭐하는 패키지 일까?
**답변 : Java의 가장 기본이 되는 패키지이다. Boolean, Integer, Math 와 같은 클래스들을 포함하고 있다.**
[lang package in java - Scaler Topics](https://www.scaler.com/topics/lang-package-in-java/)

<br><br><br>

## Wrapper Class를 사용하는 이유는 뭘까?
**답변 : Java의 클래스들은 Object를 기반으로 동작하며, 이를 지원하기 위함이다. 또한, 그 외 parse method Or AutoBoxing & UnBoxing 을 지원하기 위함이다.**

- When the Java compiler applies autoboxing?
    - 파라미터로 Correspoing wrapper class instance가 요구될 때
    - wraaper class에 primitive type value 가 assign 될 때
- When the Java compiler applies unboxing?
    - 파라미터로 primitive type value가 요구될 때
    - primitive type에 wrapper class instance가 assign 될 때
- The useful features of wrapper class
    1. primitive type value를 object로 변환
    2. java.util 패키지(ex. ArrayList, HashMap, LinkedList)의 클래스들은 object만 다루기 때문에 이를 지원함.
    3. 멀티스레딩 환경에서 동기화(synchronization)을 지원하려면 object가 요구됨.
    4. 그 외 parse, toString 같은 편리한 기능 지원

[Need of Wrapper Classes in Java - GeeksforGeeks](https://www.geeksforgeeks.org/need-of-wrapper-classes-in-java/)


<br><br><br>

## final 접근제어자는 어떤 역할을 수행하는가?
답변 : final 키워드를 메소드에 붙이면, 해당 메소드가 SubClass에서 오버라이딩되지 못하게 막을 수 있다. 또한, 클래스에 지정할 경우 immutable한 클래스를 만들 수 있다.

<br><br><br>

## Object 클래스의 equals() 메소드는 어떤 방식으로 동작?
**답변 : 주소값 비교**

x와 y라는 referece value가 있을 때, 만약 x와 y가 동일한 object를 참조한다면, x.equals(y) 는 true를 반환해야하며 그 반대도 성립해야 한다.

즉, non-null object referece들의 동일관계를 확인하기 것이 존재 목적이며, 래퍼런스 변수에 담긴 주소값이 일치하는지 비교한다.

> equals() 의 contract
> 
> - *reflexive*: an object must equal itself
> - *symmetric*: *x.equals(y)* must return the same result as *y.equals(x)*
> - *transitive*: if *x.equals(y)* and *y.equals(z),* then also *x.equals(z)*
> - *consistent*: the value of .*equals()* should change only if a property that is contained in .*equals()* changes (no randomness allowed)

<br><br><br>

### equals() 메소드를 오버라이딩 할때, hashCode() 메소드를 오버라이딩 해야하는 이유는?
**답변 : hashCode()의 *`equals consistency*: objects that are equal to each other must return the same hashCode` 조건에 의해서 오버라이딩 해야됨. hashCode를 오버라이딩안할 경우, equals에 의해 동일한 객체라고 판단되지만, 서로의 hashCode 값이 다를 수 있다.**

**Hash 관련 Collection 사용시 문제가 발생한다. HashMap에서 key 값으로 (equals를 overriding 했지만, hashCode는 overriding 하지 않은)클래스의 인스턴스를 넣을 경우, 동일한 객체를 통해 key값을 조회했을 때, hashCode 값이 다르기 때문에 조회되지 않는 현상이 발견된다.**

- .equals() method를 overriding한 클래스를 extend한 클래스를 사용할 때 violation이 발생할 수 있다.

```java
public class Money{
    public Money(int amount, String currencyCode){
        this.amount = amount;
        this.currencyCode = currencyCode;
    }
    int amount;
    String currencyCode;
    
    @Override
    public boolean equals(Object o){
        if(o == this)
            return true;
        if(!(o instanceof Money))
            return false;
        Money other = (Money)o;
        boolean currencyCodeEquals = (this.currencyCode == null && other.currencyCode == null)
                || (this.currencyCode != null && this.currencyCode.equals(other.currencyCode));
        return this.amount == other.amount && currencyCodeEquals;
    }
}

public class WrongVoucher extends Money{
    private String store;

    public WrongVoucher(int amount, String currencyCode, String store) {
        super(amount, currencyCode);
        this.store = store;
    }

    @Override
    public boolean equals(Object o){
        if(o == this)
            return true;
        if(!(o instanceof WrongVoucher))
            return false;
        WrongVoucher other = (WrongVoucher)o;

        boolean currencyCodeEquals = (this.currencyCode == null && other.currencyCode == null)
                || (this.currencyCode != null && this.currencyCode.equals(other.currencyCode));

        boolean storeEquals = (this.store == null && other.store == null)
                || (this.store != null && this.store.equals(other.store));

        return this.amount == other.amount && currencyCodeEquals && storeEquals;
    }
}

public class Main {
    public static void main(String[] args){
        Money cash = new Money(42,"USD");
        WrongVoucher voucher = new WrongVoucher(42,"USD","Amazon");

        System.out.println(voucher.equals(cash)); // false
        System.out.println(cash.equals(voucher)); // true
    }
}
```

위 예제는 *`symmetric*: *x.equals(y)* must return the same result as *y.equals(x)`  를 어긋난다.*

상속이 아닌 포함관계로 변경하여 위 조건을 충족시킨다.

```java
public class Voucher {
    Money value;
    private String store;

    public Voucher(int amount, String currencyCode, String store) {
        this.value = new Money(amount,currencyCode);
        this.store = store;
    }

    @Override
    public boolean equals(Object o){
        if(o == this)
            return true;
        if(!(o instanceof Voucher))
            return false;
        Voucher other = (Voucher)o;
        boolean valueEquals = (this.value == null & other.value == null)
                || (this.value != null && this.value.equals(other.value));
        boolean storeEquals = (this.store == null & other.store == null)
                || (this.store != null & this.store.equals(other.store));
        return valueEquals && storeEquals;
    }
}
```

> hashCode() contract
> 
> - *internal consistency*: the value of *hashCode()* may only change if a property that is in *equals()* changes
> - *equals consistency*: objects that are equal to each other must return the same hashCode
> - *collisions*: unequal objects may have the same hashCode

[Java equals() and hashCode() Contracts | Baeldung](https://www.baeldung.com/java-equals-hashcode-contracts)


<br><br><br>

## class Class 는 무엇인가? 존재 이유는?
**답변 : 런타임에 class or interface를 표현하기 위한 클래스이다. (java.lang.Class). Class 클래스의 메소드는 Reflection API에서 많이 활용된다고 한다.**

[Java.lang.Class class in Java | Set 1 - GeeksforGeeks](https://www.geeksforgeeks.org/java-lang-class-class-java-set-1/#practice)


<br><br><br>

## Reflection 은 무엇인가?
**답변 : 런타임에 메소드의 행동 or 클래스 or 인터페이스 를 확인하고 수정하기 위해 사용되는 API**

[Reflection in Java - GeeksforGeeks](https://www.geeksforgeeks.org/reflection-in-java/)

<br><br><br>

## String 클래스의 equals()는 @Contract annotation을 갖고 있던데, 이게 뭐지?
**답변 : input & output에 대한 제약조건을 명시한 것.(intellij annotation)**

[JetBrains @Contract Annotation | Baeldung](https://www.baeldung.com/jetbrains-contract-annotation)



<br><br><br>

## String 클래스의 “==” 와 equals 이 다른 이유는?
**답변 : String 클래스 뿐만 아니라, 두 행위는 애초에 서로 다른 동작을 하도록 구현되있다. “==” 는 변수에 저장되있는 값을 비교하고, equals는 변수가 참조하는 내부 값을 비교한다. 키워드로 설명하자면, “==”는 address comparison 이고, equals는 content comparison이다.**

서로 같은 문자열을 가리치는 두 String객체를 대상으로 “==” 를 수행했을 때 “true”가 나왔던 이유는, 두 객체 모두 JVM Heap에 할당되 있는 String Constant Pool 내부의 문자열을 가리키기 때문이다. 만약 String 변수에 리터럴을 할당하지 않고(ex. String a = “hello”), “new String(”hello”)”형태로 할당한다면, SCP 영역 밖에 Heap 영역에 객체가 저장되어 “==” 연산 수행시 “false”를 반환할 것이다.

[Difference between comparing String using == and .equals() method in Java - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-and-equals-method-in-java/)

<br><br><br>

## String 클래스의 객체는 어디에 저장되는가? 동일한 클래스파일에 있는 String 간에는 값은 메모리 값을 가질까?
**답변 : 클래스파일에 constant_pool 영역에 저장되 있는 상수 리터럴하고는 관계가 없다.**

- String a = “hello” : SCP(Strign Constant Pool) 저장. (SCP는 Heap에 할당된 String 전용 영역)
- String a = new String(”hello”) : Heap 저장(SCP X)



<br><br><br>

## 쓰레드의 스케줄링을 관리하는 것은 JVM인가? OS인가?
**답변 : 쓰레드의 스케줄링은 관리하는 것은 OS의 책임이다.**

다시 생각해보니, JVM에서 Thread의 priority를 설정할 수 있지만, OS의 스케줄링 기법을 직접 관여하는 것은 JVM의 Independence하다는 특성에 어긋난 것이 아닐까?

만약 JVM이 OS의 스케줄링 기법에 관여할 수 있다고 가정하자. OS에는 무수한 프로세스가 동작한다. 앞선 가정은 OS라는 플랫폼을 JVM이라는 사용자가 control한다는 의미이기 때문에 성립되지 않는다.

그래서 Java에서는 Thread에 Priority 속성을 제공하나보다. 실행 순서를 정확하게 예측할 수는 없지만, 어느정도 우선순위를 지정하고, 나머지는 OS에 맡기는 형태인 것으로 보인다.

신기한 것은, Java 21에서 Platform threads & Virtual threads 라는, OS thread와 직접 연결지어 스케줄링을 관리할 수 있는 Thread를 제공한다는 것이다. 신기하구만.

[How JVM thread scheduler control threads for multiprocessors?](https://stackoverflow.com/questions/41759261/how-jvm-thread-scheduler-control-threads-for-multiprocessors)

[Java® Platform, Standard Edition & Java Development Kit Version 21 API Specification](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#virtual-threads)