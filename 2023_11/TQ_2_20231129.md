## java thread는 PC를 갖고 있나?
**답변 : 그렇다.** 

각각의 JVM thread는 자신만의 PC(program counter)를 갖고 있다. JVM의 runtime-data-area 에는 PC값을 저장하는 영역이 존재한다. OS에서의 thread와 헷갈려서 위와 같은 질문을 했던 것 같다.

OS에서는 여러 프로세스가 동작하고 각각에 프로세스에 쓰레스가 존재한다. 이 때문에 잠시 JVM의 thread도 여러 프로세스에 포함된 개념으로 착각했다.(JVM 자체가 프로세스인데 말이다.)

> Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread.
>

<br><br><br>

## 나는 synchronized 키워드가 적용된 멤버 메소드 그룹을 scope로하여 적용될 것으로 추측한다. 실제로 그렇한가? 적용 범위는?
- synchronized method

| lock 적용여부 | synchronized method | static synchronized method |
| --- | --- | --- |
| normal method | X | X |
| synchronized method | O | X |
| static synchronized method | X | O |

**synchronized method는 객체(object)에 대해서 lock**이 걸린다. 만약 같은 클래스의 서로다른 인스턴스(A,B) 가 존재하며, 두 스레드가 **각각에 인스턴스의 synchronized method에 접근할 경우 lock이 걸리지 않는다.**

> 1개의 유니크한 객체의 synchronized method들에 대해 여러 스레드가 접근할 때 lock이 걸리는 것이다. 단수형(method)이 아닌 복수형(methods) 임에 유의하자!! (필자는 매번 헷갈린다...ㅠ)
> 

**static synchronized method**는 객체(object)가 아닌 **Class에 대해 lock이 걸린다.**

'Class'라는 단어 때문에, 그러면 Class에 있는 모든 method에 대해 lock이 걸리나??? 라고 오해할 수 있다.

**'Class' 클래스가 보유하고 있는 static synchronized method들 에 대해 lock이 걸린다.**

아래 글은 위 내용을 정리하는 데 활용한 자료이며, 필자 기준에서, method level & class level 의 차이를 가장 잘 설명했다고 생각되어 링크를 남긴다.

[If a synchronized method calls another non-synchronized method, is there a lock on the non-synchronized method](https://stackoverflow.com/questions/9525882/if-a-synchronized-method-calls-another-non-synchronized-method-is-there-a-lock)



<br><br><br>

## 실무에서 자바 thread의 priority를 활용할까? (테스트 했을때는 실행 순서를 예상하기 힘들다고 판단되었음.)
답변 : 대부분 사용하지 않는 것으로 보인다. 왜냐하면, OS 스케줄링에 거의 영향을 주지 않기 때문이다.

스레드 실행의 우선순위는 OS가 결정한다. 또한, Implementation dependent하기 때문에 각각의 OS들 마다 처리방식이 다르다. 따라서, OS와의 관계에서 JVM은 Process이기 때문에 스레드의 실행 우선순위를 결정할 권한이 없다.

책 ‘자바 병렬 프로그래밍(저자 : 브라이언 게츠)’에 따르면, 아래와 같다고 한다.

> 스레드 우선순위를 사용하려는 유혹을 피하세요. 스레드 우선순위는 플랫폼 의존성을 높이고 활성 문제를 일으킬 수 있기 때문입니다. 대부분의 concurrent application은 the default priority를 사용합니다.
> 

또한, 스레드 우선순위를 지정한다고 해도, OS에서 해당 힌트들을 적용한다는 보장이 없기 때문에, 차라리 사용하지 않는 것이 혼동이 없는데 도움이 될 것 같다.

[Java Thread priority has no effect](https://stackoverflow.com/questions/12038592/java-thread-priority-has-no-effect)

[Why thread priority rarely matters](https://blog.vanillajava.blog/2011/09/why-thread-priority-rarely-matters.html#!/2011/09/why-thread-priority-rarely-matters.html)


<br><br><br>

## 데드락은 무엇인가? 직접 구현해보자
### DeadLock 예제

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        DeadLockTestThread.ThreadDemo1 T1 = new DeadLockTestThread.ThreadDemo1();
        DeadLockTestThread.ThreadDemo2 T2 = new DeadLockTestThread.ThreadDemo2();
        T1.start();
        T2.start();
    }
}

public class DeadLockTestThread {
    public static Object Lock1 = new Object();
    public static Object Lock2 = new Object();

    public static class ThreadDemo1 extends Thread{
        @Override
        public void run() {
            synchronized (Lock1){
                System.out.println("Thread 1: Holding lock 1...");

                try {Thread.sleep(100);
                } catch (InterruptedException e) {throw new RuntimeException(e);}
                System.out.println("Thread 1: Waiting for lock 2...");

                synchronized (Lock2){
                    System.out.println("Thread 1: Holding lock 1 & 2...");
                }
            }
        }
    }
    public static class ThreadDemo2 extends Thread{
        @Override
        public void run() {
            synchronized (Lock2){
                System.out.println("Thread 2: Holding lock 2...");

                try {Thread.sleep(100);
                } catch (InterruptedException e) {throw new RuntimeException(e);}
                System.out.println("Thread 2: Waiting for lock 1...");

                synchronized (Lock1){
                    System.out.println("Thread 2: Holding lock 1 & 2...");
                }
            }
        }
    }
}

//> Task :Main.main()
// Thread 1: Holding lock 1...
// Thread 2: Holding lock 2...
// Thread 1: Waiting for lock 2...
// Thread 2: Waiting for lock 1...
```

### DeadLock 해결 예제

단순하게 서로 엇갈리게 Lock을 잡고 있던 것을 바꾸면 된다.

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        DeadLockTestThread.ThreadDemo1 T1 = new DeadLockTestThread.ThreadDemo1();
        DeadLockTestThread.ThreadDemo2 T2 = new DeadLockTestThread.ThreadDemo2();
        T1.start();
        T2.start();
    }
}

public class DeadLockTestThread {
    public static Object Lock1 = new Object();
    public static Object Lock2 = new Object();

    public static class ThreadDemo1 extends Thread{
        @Override
        public void run() {
            synchronized (Lock1){
                System.out.println("Thread 1: Holding lock 1...");

                try {Thread.sleep(100);
                } catch (InterruptedException e) {throw new RuntimeException(e);}
                System.out.println("Thread 1: Waiting for lock 2...");

                synchronized (Lock2){
                    System.out.println("Thread 1: Holding lock 1 & 2...");
                }
            }
        }
    }
    public static class ThreadDemo2 extends Thread{
        @Override
        public void run() {
            synchronized (Lock1){
                System.out.println("Thread 2: Holding lock 1...");

                try {Thread.sleep(100);
                } catch (InterruptedException e) {throw new RuntimeException(e);}
                System.out.println("Thread 2: Waiting for lock 2...");

                synchronized (Lock2){
                    System.out.println("Thread 2: Holding lock 1 & 2...");
                }
            }
        }
    }
}

//> Task :Main.main()
// Thread 1: Holding lock 1...
// Thread 1: Waiting for lock 2...
// Thread 1: Holding lock 1 & 2...
// Thread 2: Holding lock 1...
// Thread 2: Waiting for lock 2...
// Thread 2: Holding lock 1 & 2...
```



