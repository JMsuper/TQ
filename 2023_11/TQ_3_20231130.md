## Interface는 어떻게 Object 클래스의 메소드를 사용할 수 있을까?

이번 글은 위 질문에 대한 검증을 위해 작성하였다. stackoverflow에 위 질문을 검색하면 많은 답변이 나온다.

[답변 내용은 다음과 같다](https://stackoverflow.com/questions/6056124/do-interfaces-inherit-from-object-class-in-java),

JLS(Java Language Spec)에서는, 인터페이스가 상위 인터페이스를 상속받지 않고 독립적인 인터페이스라면, 암묵적으로 Object의 public instance method를 인터페이스의 public abstract method로 추가해준다고 한다.

> JLS - 9.2 Interface Members
> 
> 
> **then the interface implicitly declares a public abstract member method m with signature s, return type r, and throws clause t corresponding to each public instance method m with signature s, return type r, and throws clause t declared in Object**
> 

그런가 보다하고, 넘어갔었다.

이후 클래스 로더를 공부하는 중 당황해버렸다...   JVM Specification에서는 JLS와는 다른 명세가 있었다.

> JVM Specification - 5.3.5. Deriving a Class from a class File Representation
> 
> 
> **Note that if C is an interface it must have Object as its direct superclass,**
> 

**JVM 명세에서는, 인터페이스가 반드시 그것의 직속 상위클래스로 Object를 가지고 있어야 된다고 한다.**

각자의 의견을 정리하면 다음과 같다.

- StackOverFlow : 인터페이스는 Object를 상속하지 않습니다.
- Java Lang Spec : 암묵적으로 Object의 public instance method를, 인터페이스에 public abstract method로 생성합니다.
- JVM Spec : 인터페이스는 반드시 Object 클래스를 상위클래스로 갖고 있어야 합니다.

물론 Specification은 말그대로 명세이기 때문에 기술적으로 JLS와 JVM Spec이 일치하지 않을 수 있다는것은 인정한다. 하지만, 각각의 문서에서 말하는 것이 서로 달랐기 때문에, JVM의 구현체에서는 어떻게 동작하는지 내 눈으로 직접 확인하고 싶었다.

---

### 검증 1 : 인터페이스 변수에서 Object 클래스의 method를 호출

- 인터페이스 래퍼런스 변수에 null을 assign한 경우

```java
public class Main {
    public static void main(String[] args) {
        TestInterface testInterface = null;
        testInterface.equals(null);
    }
}

interface TestInterface {}
```

> 결과 : Exception in thread "main" java.lang.NullPointerException at org.example.Main.main(Main.java:6)
> 

인스턴스 메소드는 객체가 존재해야만 호출이 가능하기 때문에, 인스턴스를 생성할 수 없는 인터페이스의 특성상,

Object 클래스의 인스턴스 메소드를 호출할 경우 **NullPointerException을 throw**할 것이다.

- 인터페이스 래퍼런스 변수에 인터페이스의 구현체를 assign한 경우

```java
public class Main {
    public static void main(String[] args) {
        TestInterface testInterface = new TestClass();
        System.out.println(testInterface.equals(testInterface));
    }
}

class TestClass implements TestInterface {}

interface TestInterface {}
```

> 결과 : true
> 

정상적으로 Object 클래스의 메소드를 호출하기 위해,

인터페이스 래퍼런스 변수에 인터페이스의 구현체를 할당하고 메소드를 호출하였다.

위 결과를 통해 **"Interface는 Object 클래스의 메소드를 호출할 수 있다."** 를 증명하였다.

### 검증 2 : 인터페이스의 바이트코드 확인

바이트코드를 통해 확인하고 싶은 것은 다음과 같다.

- (JSL)Object 클래스의 public instance method가 public abstract method의 형태로 추가되었는가?
- (JVM Spec)인터페이스는 Object 클래스를 상속하는가?
- 

컴파일한 코드 디컴파일한 바이트코드는 다음과 같다.

```java
public interface TestInterface {
    void foo();
}
```

```bash
(base) PS C:\Users\A\Desktop\project\DesktopAlarmApplication\alarm_application\build\classes\java\main\org\example> javap -v .\TestInterface.class
Classfile /C:/Users/A/Desktop/project/DesktopAlarmApplication/alarm_application/build/classes/java/main/org/example/TestInterface.class
  Last modified 2023. 11. 30; size 139 bytes
  MD5 checksum fe7cca9bf6b2d39cde172d193f089da2
  Compiled from "TestInterface.java"
public interface org.example.TestInterface
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT
Constant pool:
#1 = Class              #7              // org/example/TestInterface#2 = Class              #8              // java/lang/Object#3 = Utf8               foo#4 = Utf8               ()V#5 = Utf8               SourceFile#6 = Utf8               TestInterface.java#7 = Utf8               org/example/TestInterface#8 = Utf8               java/lang/Object
{
  public abstract void foo();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_ABSTRACT
}
SourceFile: "TestInterface.java"
```

위 바이트코드에서 "void foo()" 는 "public abstract void foo()" 로 변환되었다. 추상 메소드는 바이트 코드에 표시된다.

하지만, Object의 인스턴스 메소드들이 추상 메소드로 추가되지 않은 것을 보아,

**실제 구현체**에서는 JLS에서 명세한 것과는 다르게

> Object 클래스의 public instance method가 public abstract method의 형태로 추가하지 않음
> 

을 확인하였다.

그렇다면, 인터페이스는 Object 클래스를 암묵적으로(그리고 내부적으로) 상속받은 것일까?

!https://blog.kakaocdn.net/dn/chdpVG/btsBfcci1Zo/pV6hBcjhhJSPFklsHzxjE0/img.png

상속 받지 않은 인터페이스

!https://blog.kakaocdn.net/dn/V9PMe/btsBeNKAcXS/saJR9e6uKAgRihr4dafe0K/img.png

다른 인터페이스를 상속받은 인터페이스

다른 클래스나 인터페이스를 상속받을 경우, 위와 같이 바이트코드에 "extends org.example.TestInterface" 형태로 표시된다. 필자는 이를 근거로 **인터페이스는 Object를 상속받지 않는다고 결론 지으려고 했다.**

**그러나** Object 클래스를 기본적으로 상속받는 클래스의 경우에도 "extends java.lang.Object" 와 같은 표시는 되어있지 않았다. 즉, 애초에 **Object 클래스를 상속받는다는 표시는 바이트코드에 드러나지 않는 것**이다.

```java
public class TestClass{}
```

!https://blog.kakaocdn.net/dn/dMazty/btsBb9m5PHC/VPVbce9AKK3bdwfcclJuMk/img.png

다른 클래스를 상속받지 않은 일반 클래스

자바에서 모든 클래스가 Object 클래스를 상속받는다는 사실은 너무나 당연한 사실인데, 이 부분에서 막혔다.

그러던 중, 인터페이스와 클래스의 바이트코드 사이에 공통점을 발견하였다.

### 검증 3 : 인터페이스와 클래스 바이트코드 상 공통점

!https://blog.kakaocdn.net/dn/rXPks/btsBcbFc5gt/x9UN1Png7rCss9JpaFC3V0/img.png

클래스의 바이트코드의 Constant pool

!https://blog.kakaocdn.net/dn/c9L08O/btsBbJvgRaE/AI9S6zSfMkXdXqw6c5me50/img.png

인터페이스의 바이트코드 의 Constant pool

위 이미지는 두 바이트코드의 Constant pool을 나타낸 것이다. 공통점은 Object 클래스에 대한 네이밍을 Constant pool에 담고 있다는 것이다. 해당 클래스 or 인터페이스에서 Object의 인스턴스 메소드를 호출한다면, Constant pool에 있는 Object 클래스의 네이밍을 활용하여 함수를 호출할 것이다.

**그럼 둘 다 Object 클래스를 상속받은 것일까? 그건 아니라고 본다.**

클래스의 경우, constant pool의 첫번째 인덱스에 'java/lang/Object."<init>"' 이라는 Object 클래스의 생성자를 갖고 있다 (실제 보유하는 것이 아니라 네이밍을 갖고 있음을 의미함). 

상속이라는 관점에서 봤을 때, 상속받은 SubClass는 SuperClass의 생성자를 호출할 수 있어야 한다. 왜냐하면 SubClass의 인스턴스를 생성한다는 것은 SuperClass의 인스턴스 또한 내부에 생성함을 의미하기 때문이다.

이러한 근거로 위 이미지에서 **"클래스"는 Object 클래스를 상속받았다**고 말할 수 있다.반면에, "인터페이스"는 Object 클래스의 생성자를 호출할 수 없기 때문에, **"인터페이스"는 Object 클래스를 상속받지 않았다**고 말할 수 있다.

### 검증 1~3 내용 정리

> 
> 
> - StackOverFlow : 인터페이스는 Object를 상속하지 않습니다.
> - Java Lang Spec : 암묵적으로 Object의 public instance method를, 인터페이스에 public abstract method로 생성합니다.
> - JVM Spec : 인터페이스는 반드시 Object 클래스를 상위클래스로 갖고 있어야 합니다.

글의 초반에, 필자는 질문에 대해 위와 같은 답변을 얻었다고 말하였다. 그럼 위 말들은 전부 잘못된 것일까?

**전부 맞는 말이라고 생각한다.** 하나씩 설명하겠다.

- *StackOverFlow : 인터페이스는 Object를 상속하지 않습니다.*

인터페이스는 Object 클래스의 생성자를 호출할 수 없기 때문에, 위 말은 맞는 말이다.

- *Java Lang Spec : 암묵적으로 Object의 public instance method를, 인터페이스에 public abstract method로 생성합니다.*

문장만 본다면 잘못된 말이라고 볼 수 있다. 왜냐하면, 바이트코드에서 Object 클래스의 인스턴스 메소드들이 추상 메소드의 형태로 추가되어 있지 않았기 때문이다. 하지만, **JLS는 명세일 뿐**, 구현체가 아니다. 즉, 실제 구현해야할 대상에 대한 **설계도 혹은 청사진**이라고 판단해야한다.

이러한 관점에서, 인터페이스가 Object 클래스의 메소드를 갖는다는 것의 의미는, 추상 메소드를 활용하여 구현 클래스들이 해당 메소드를 overriding 해야함을 강제하기 위함이 아니다.

**인터페이스가 Object 클래스의 메소드를 갖는다는 것의 의미는, 인터페이스 래퍼런스 변수에 구현 클래스의 인스턴스가 할당되었을 때 Object 클래스가 갖고 있는 메소드을 해당 변수에서 호출할 수 있게 해준다는 것이 더 중요한 포인트이다.**

```java
public class Main {
    public static void main(String[] args) {
        TestInterface testInterface = new TestImple();
        testInterface.hashCode();
    }
}

class TestImple implements TestInterface{}

interface TestInterface{}
```

위와 같은 케이스에서, 만약 TestInterface 인터페이스가 Object 클래스의 네이밍을 Constant pool에 가지고 있지 않다면, "hashCode()" 와 같은 Object 클래스의 인스턴스 메소드는 사용할 수 없을 것이다.

- JVM Spec : 인터페이스는 반드시 Object 클래스를 상위클래스로 갖고 있어야 합니다.

물론 인터페이스가 Object 클래스를 상속받지 않는다는 것은 자명하다. 그러나, 다시 JVM Spec을 확인해보니 필자가 문서를 잘못이해했다는 생각이 들었다.

> 
> 
> 
> JVM Specification - 5.3.5. Deriving a Class from a class File Representation
> 
> [...]
> 
> If  C has a direct superclass, the symbolic reference from C to its direct superclass is resolved using the algorithm of §5.4.3.1. Note that if C is an interface it must have Object as its direct superclass, which must already have been loaded. Only Object has no direct superclass.
> 
> [...]
> 
> (C : 클래스 로더의 Loading 대상이 되는 class or interface)
> 

**모든 클래스와 인터페이스는 반드시 Object 클래스를 상속받거나 최소한 Object 클래스의 메소드를 호출할 수 있어야 한다. 그렇지 않으면 객체지향에서 말하는 다형성을 구현할 수 없다.**

이러한 관점에서 본다면, 비록 인터페이스가 Object 클래스를 상속받지는 않지만, Object 클래스가 인터페이스의 상위클래스라는 말은 맞다고 생각한다.

---

### **결론**

**인터페이스는 컴파일 시 바이트코드의 constant pool에 Object 클래스의 네임을 넣음으로써,**

**Object 클래스의 인스턴스 메소드 호출을 가능하게 하였다.**

참고자료

- https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.1
- https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.1
- https://stackoverflow.com/questions/6056124/do-interfaces-inherit-from-object-class-in-java
- https://geekexplains.blogspot.com/2008/06/do-interfaces-really-inherit-from-class.html



<br><br><br>

## 자바 클래스파일(*.class) 포맷

-   출처 : [https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf) (4. The class File Format)
​
class 파일은 다음과 같은 구조를 갖는다.
​
-   u1, u2, u4 는 각각 1B, 2B, 4B 를 의미함.
​
```
ClassFile {
 u4 magic;
 u2 minor_version;
 u2 major_version;
 u2 constant_pool_count;
 cp_info constant_pool[constant_pool_count-1];
 u2 access_flags;
 u2 this_class;
 u2 super_class;
 u2 interfaces_count;
 u2 interfaces[interfaces_count];
 u2 fields_count;
 field_info fields[fields_count];
 u2 methods_count;
 method_info methods[methods_count];
 u2 attributes_count;
 attribute_info attributes[attributes_count];
}
```
​
-   magic : class 파일의 포맷을 구분하기 위한 값. 0xCAFEBABE 를 가짐.
-   minor\_version, major\_version : class 파일의 버전을 의미. 파일 버전을 지칭할 때는 M.m. 으로 표현한다. M은 메이저, m은 마이너. 다시말해 Mi.0 ≤ v ≤ Mj.m 범위의 파일 포맷임을 의미. JDK의 release 버전에 따라서 지원하는 클래스파일 포맷 버전이 존재하므로 이를 확인하기 위한 것으로 보인다.
-   constant\_pool\_count : constant\_poo 테이블의 길이.
-   constant\_pool\[\] : constant\_pool 테이블 배열. constant\_pool 테이블의 각 엔트리의 포멧은 첫번째 ‘tag’ byte 를 통해 명시됨.
-   access\_flags : class 파일을 통해 구현될 class와 interface의 접근 권한을 명시함. 마스킹 타입으로 표현됨. 0x0000
-   this\_class : constant\_pool에 담긴 CONSTANT\_Class\_info 구조체 엔트리의 인덱스. 해당 구조체는 클래스 또는 인터페이스를 표현한다.
-   super\_class : constant\_pool에 담긴, 상위 클래스 또는 상위 인터페이스의 CONSTANT\_Class\_info 구조체 엔트리의 인덱스. 만약 0이라면 해당 class 파일은 Object를 나타낸다. 그게 아니라면 반드시 0이 아닌 값이 담겨야 한다.
-   interfaces\_count : implement한 인터페이스 개수.
-   interfaces\[\] : 인터페이스의 정보를 담은 구조체(CONSTANT\_Class\_info)가 constant\_pool에서 어떤 인덱스에 담겨있는지 나타냄. 소스에 표시된 순서대로(왼쪽 → 오른쪽) 배열에 인덱스가 담겨짐.
-   fields\_count : fields\[\] 테이블의 길이.
-   fields\[\] : 여기서 의미하는 field는 클래스 멤버 변수, 인스턴스 변수를 의미. field\_info 구조체가 담김.
-   methods\_count : methods\[\] 테이블의 길이.
-   method\[\] : method\_info 구조체를 담은 배열. super class에서 상속받은 메소드는 담겨있지 않음.
-   attributes\_count : attributes\[\] 테이블의 길이
-   attributes\[\] : attribute\_info 구조체를 담은 배열. attribute는 무엇인가? Classfile, filed\_info, method\_info, Code\_attribute 에 대한 특성값을 지정하기 위한 것이다. 내용이 방대하여 전부 알 필요는 없을 듯 하다.