## 클래스 로더는 어떻게 동작하는가?
클래스 로더의 가장 기본적인 역할은, 클래스 파일(*.class)을 읽어들여, JVM이 클래스를 활용할 수 있게 도움주는 것이다. 처음 JVM을 공부할 때는 단순하게 위와 같이 이해하였다. 그러나, 파고들수록 궁금한 것들 생겨났다.

- 클래스 로더는 ClassLoader 클래스의 하위클래스라고 하던데, 태초의 ClassLoader 클래스는 누가 JVM에 적재해두는 것일까?
- Enum 클래스는 싱글톤 패턴으로 동작한다고 하는데, 이때 클래스 로더가 도와준다고 한다. 어떻게 도와주는 것일까?
- 클래스 로더는 synchronized하게 동작한다는데, 그 말인 즉슨, 클래스 파일을 Load할때도 synchronized하다는 것을 의미할 것이다. 어떻게 구현했을까?

위 질문을 해결해줄 내용들을 정리하였다.

<br><br><br>

# JVM StartUp

JVM은 특정 클래스의 main() 메소드를 실행하므로써 시작하게 된다. “java” 명령어와 뒤에 main() 메소드를 포함하고 있는 클래스의 이름을 입력하여, cmd창에 실행한다.

<aside>
💡 java org.example.Main

</aside>

가장 첫번째로 JVM은 해당 클래스의 Class 클래스가 Method Area에 load되었는지 확인한다. JVM은 이 클래스에 대한 정보가 찾지 못하였기 때문에, 클래스 로더에게 해당 클래스의 바이트코드를 찾아달라는 요청을 전달하고, 클래스 로더는 바이트코드를 찾은 이후 method area 영역에 Class 클래스의 인스턴스(Main 클래스의 것)을 생성한다. - Load 단계

Main 클래스의 Class 클래스(이하, Main 클래스)가 Method Area load된 이후, main() 메소드가 실행되기 전, 먼저 Main 클래스와 관련있는 클래스들이 Link되어야 하고 Initialization 되어야 한다(자세한 내용은 뒤에서 설명하겠다). Link 단계에서는 검증(verification), 준비(preparation),  확인(resolution, 오역일 수 있음)

Link-검증 단계에서는 Main 클래스에 대한 포맷이 정상적인지, 적절한 심볼릭 테이블을 갖고 있는지, Main 클래스가 갖고 있는 Code가 JAVA와 JVM에 위배되지는 않는지 확인한다. Link-준비 단계에서는 Main 클래스와 관련하여 JVM 내부적으로 사용될 메모리 영역(static 영역, 데이터 구조)을 할당한다. (다만, 할당만 할 뿐이지 실제 초기화는 이후 Initialization에서 수행된다). Link-확인 단계에서는 Main 클래스의 심볼릭 참조와 관련하여 관련된 클래스들을 load하고(재귀적으로 동작), 심볼릭 참조와 앞서 load한 클래스들이 일치하는 지 확인한다(확인 단계는 JVM 구현체 마다 다르며, 선택사항임). - Link 단계

Link 단계가 완료된 이후, Initialization을 진행한다. 이 단계에서 Main 클래스의 멤버 변수의 초기화와 static 영역 초기화를 수행한다. 초기화는 클래스 소스코드 상 “위 → 아래” 방향으로 진행된다. 만약 Initialization을 수행중인 클래스의 상위 클래스가 존재할 경우, 해당 상위 클래스의 초기화가 먼저 진행되어야 한다. 이 경우 재귀적으로 (상위클래스의 Load 단계부터) 수행된다. 상위 클래스의 초기화가 모두 종료되면 Main 클래스의 초기화가 진행되고 완료될 것이다.

이제 main() 메소드는 method area에 적재되었다. JVM은 main 함수 블럭으로 들어가 프로그래의 시작을 진행한다. 위 글은 간략하게 설명한 것이다.

사실 Main 클래스에 관한 작업을 수행하기전, JVM은 가장 기초적인 작업을 수행하게 된다. 예를 들자면, 우선 Main 클래스를 로드할 클래스 로더의 객체를 생성해야 한다. 이러한 내용은 잘 모르기 때문에 관련 자료를 참조한다.

[How to Warm Up the JVM | Baeldung](https://www.baeldung.com/java-jvm-warmup)

<br><br><br>

# 클래스 로더란?

클래스 로더는 런타임 동안 JVM에 자바 클래스들을 적재하는 역할을 수행한다. 자바 클래스를 all at once하게 로드하는 것은 아니다. 대신, 어플리케이션에 의해 해당 특정 자바 클래스가 요구될 때, 그 클래스를 로드한다. 다만, 핵심기능을 수행하는 기본 자바 클래스들은 초기에 미리 적재해두고, 그외 클래스들은 필요할 때 적재해준다. 이를 Lazy Loading이라고 부른다.

Java 공식 문서에서는 클래스 로더에 대해 두 가지 종류로 구분한다. JVM에 의해 제공되는 bootstrap 클래스 로더와 user-defined 클래스 로더이다. 모든 user-defined 클래스 로더는 ClassLoader 클래스의 하위 클래스이다.

<br>

## 클래스 로더 세 가지

실제 구현체에서는 세 가지 타입으로 나눠서 구분한다. Bootstrap, Extension, System(Application)이다.

### Bootstrap, Extension, System(Application)

- Bootstrap 클래스 로더
    
    JVM이 처음 시작될때 실행되는 클래스로더이며, 상위 클래스로더를 갖지 않는 클래스로더이다. 머신코드로 이뤄져 있으며, java로 구성되있는 pure Java 클래스로더를 로드하는 일을 수행한다. “/rt.jar”에 위치하고 있는 클래스들을 로드한다.
    

- Extension 클래스 로더
    
    BootStrap 클래스로더의 하위 클래스이다(구현체에서는 ClassLoader 클래스의 하위클래스로 되어있다). 코어 자바 클래스에서 확장된 클래들을 로드하며, 각각의 JDK Extension Library에서 클래스를 로드한다. “jre/lib/ext” 또는 “java.ext.dirs”라는 시스템 프로퍼티에 명시된 디렉토리에서 클래스를 로드한다.
    

- System(Application) 클래스 로더
    
    Application ClassLoader라고 불려지며, CLASSPATH에서 발견되는 application-level의 클래스를 로드한다. Extension ClassLoader의 하위 클래스이다. 마찬가지로 ClassLoader의 Sub클래스이다.
    
    실제 구현체에서는 다음과 같은 상속관계를 갖는다. ClassLoader ← SecureClassLoader ← URLClassLoader ← AppClassLoader
    

The ClassLoader Delegation Hierarchy Model은 항상 Application ClassLoader → Extension ClassLoader → Bootstrap ClassLoader의 순서로 진행된다.

클래스로더는 다음 세가지 원칙을 기반으로 동작한다. 

- **Delegation Model**
    1. JVM이 클래스를 발견하면, 해당 클래스가 메모리에 로드되었는지 아닌지 확인한다.
    2. 만약 클래스가 이미 로드되었다면, JVM은 실행을 계속 진행한다.
    3. method area 영역에 클래스가 로드되있지 않을 경우, JVM은 클래스로더 sub-system에게 해당 클래스를 로드하도록 요청한다. 클래스로더 sub-system은 권한을 Application ClassLoader에게 전달한다.
    4. Application ClassLoader → Extension ClassLoader → Bootstrap ClassLoader의 순서로 요청이 위임된다.
    5. Bootstrap ClassLoader는 Bootstrap classpath(jdk/jre/lib)를 조사할 것이다. 만약 클래스가 발견되면 해당 클래스를 로드하고, 없을 경우 요청을 Extension ClassLoader에게 위임한다.
    6. Extension ClassLoader는 Extension classpath(jdk/jre/lib/ext)를 조사할 것이다. 만약 클래스가 발견되면 해당 클래스를 로드하고, 없을 경우 요청을 Application ClassLoader에게 위임한다.
    7. Application ClassLoader는 Application classpath(CLASSPATH)를 조사할 것이다. 만약 클래스가 발견되면 해당 클래스를 로드하고, 없을 경우 ClassNotFoundException 예외를 발생시킨다.
- **Visibility Principle** : 부모 클래스로더에게 load된 클래스는 자식 클래스로더에게 보여지지만, 그 반대는 성립되지 않는다. 만약 자식 클래스로더에서 load된 클래스에 대해, 부모 클래스로더에게 load를 요청한다면, 부모클래스는 클래스가 load된 사실을 알지 못하기 때문에ClassNotFoundException 예외를 발생시킨다.
- **Uniqueness Property** : 클래스가 유니크하고 오직 한개만 존재하도록 보장한다. 부모 클래스로더에게 load된 클래스는 자식 클래스로더에서 다시 load되지 않도록 한다. 오직 부모 클래스로더가 요청받은 클래스를 찾을 수 없을 때만, 자식 클래스로더에게 요청이 전달될 것이다.

<br>

### 클래스로더의 메소드

- loadClass(String name, boolean resolve) : JVM에 의해 참조된 클래스를 로드하는 데 사용된다.
    
    메소드 내 호출 순서는 다음과 같다.
    
    1. findLoadedClass(String) 을 호출하여 class의 load여부를 확인한다.
    2. load되있지 않다면, 부모 클래스로더의 loadClass 메소드를 호출한다.
    3. 부모 클래스로더에서 클래스가 발견되지 않았다면, findClass 메소드를 호출한다.
    4. (번외) findClass 내부에서는 defineClass를 호출한다. defineClass는 JVM 메모리에서 Class 클래스의 인스턴스를 생성을 위한 영역을 할당한다.
    
    아래 코드는 ClassLoader.java에서 발췌된 loadClass 메소드이다. synchronized 키워드를 통해 동시성 제어를 수행하는 것을 알 수 있다. **이 특징을 통해 Class 클래스의 인스턴스는 싱글톤하게 생성된다.**
    
    ```java
    protected Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException
        {
            synchronized (getClassLoadingLock(name)) {
                // First, check if the class has already been loaded
                Class<?> c = findLoadedClass(name);
                if (c == null) {
                    long t0 = System.nanoTime();
                    try {
                        if (parent != null) {
                            c = parent.loadClass(name, false);
                        } else {
                            c = findBootstrapClassOrNull(name);
                        }
                    } catch (ClassNotFoundException e) {
                        // ClassNotFoundException thrown if class not found
                        // from the non-null parent class loader
                    }
    
                    if (c == null) {
                        // If still not found, then invoke findClass in order
                        // to find the class.
                        long t1 = System.nanoTime();
                        c = findClass(name);
    [...]
                    }
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }
    ```
    
- defineClass() : array of bytes 를 Class 클래스의 인스턴스를 위한 메모리로 변환한다. 변환된 클래스가 사용가능해지기 전에 반드시 resolve 과정을 거쳐야 한다.
- findCLass(String name) : 클래스를 찾는 메소드이며, 찾을 뿐 load하지는 않는다.
- findLoadedClass(String name) : JVM에 의해 참조된 클래스가 load되었는지 아닌지 확인한다.
- Class.forName(String name, boolean initialize, ClassLoader loader) : 클래스를 로드하고 동시에 초기화를 수행하는데 사용된다. 클래스로더를 선택할 수 있는 옵션을 제공하며, 만약 null로 둘 경우 Bootstrap 클래스로더가 사용된다.

<br>

### Why use Delegation Model?

- Security
    
    변경되어서는 안되는 특정 클래스들이 존재한다. 부모 클래스 로더가 먼저 load하도록 하는 delegation model을 사용하여, JVM은 커스텀한 클래스 로더가 아닌, 특정 클래스 로더들만 load할 수 있도록 한다. 이를 통해 클래스의 악의적 변경을 방지한다.
    
- Avoid duplicate class instances
    
    클래스 로딩 작업은 비용이 많이 들어가는 작업이다. 때문에, JVM이 클래스를 오직 한개의 클래스만 로드할 수 있도록 제한한다. 부모 클래스로더가 우선적으로 load를 시도함으로써 이를 구현한다.
    

<br><br><br>

# Load, Link, Initialization

## Load

Load단계는 JVM의 Method Area에 클래스의 생성하여 적재하는 일련의 과정을 말한다. 클래스에 대한 Load 요청은 해당 클래스를 run-time constant pool에서 참조한 다른 클래스에 의해 발생한다. 또한, 해당 클래스의 메소드 호출도 클래스 생성을 야기한다. 만약 클래스가 Array 클래스라면, 클래스 로더가 아닌 JVM에 의해 생성된다. 

일반적으로, 런타임 동안에 클래스는 ‘클래스의 이름’으로 구분된다고 생각된다. 사실은, ‘클래스의 이름’과 해당 클래스를 적재한 ‘클래스 로더’의 한 쌍으로 구분된다. 즉, BClassLoader에 의해 메모리에 적재된 A라는 클래스가 있다면, 런타임에 해당 클래스는 <A, BClassLoader> 로 구분되게 된다. 

<br>

## Link

Link는 클래스를 검증하고 준비(초기화를 준비)하는 단계이며, 필요하다면 관련 상위클래스 or 상위 인터페이스 or 구성요소의 type에 대해서도 확인을 수행한다. Resolution(확인) 절차는 선택사항이다(Java7 기준). Link 단계는 아래의 조건을 따른다.

- 클래스는 Link 단계 이전에 반드시 Load가 완료되어야 한다.
- 클래스의 veriy & prepare 절차는 Initialization 단계 이전에 완료되어야 한다.

<br>

### Verify

Verification(검증) 절차는 클래스 파일을 통해 생성된 클래스가 구조적으로 잘못된 부분이 없는지 보장한다. 물론, 앞선 단계에서 컴파일러가 구조적 조건에 맞춰 클래스파일을 컴파일 했겠지만, 해당 클래스 파일이 신뢰할 수 있는 컴파일러에게 컴파일된 것인지 JVM은 알 수 없다. 이러한 이유로 검증할 필요성이 있는 것이다. 다음의 사항들을 확인한다.

- final 클래스가 다른 클래스에 의해 상속되었는가? 혹은 final 메소드가 overriding 되었는가?
- Object 클래스를 제외한, 모든 클래스가 직속 상위클래스를 갖고 있는가?
- constant pool이 CONSTANT_Class_info 구조를 잘 따르고 있는가?
- constant pool에 있는 ‘필드 참조’ & ‘메소드 참조’가 정상적인 이름 & 클래스 & 리턴타입 을 가지고 있는가?

하지만, 이 절차가 정말로 해당 조건들이, 주어진 필드 & 메소드 & 클래스 들이 존재하는지는 보장하지 않는다. 다만, 구조적으로 정상적인지를 확인하는 것이다. 더 디테일한 확인은 바이트코드 자체적으로 확인이 이뤄지고 Resoultion 단계에서 진행된다.

<br>

### Prepare

Preparation(준비) 절차에서는 클래스의 ‘static’ 필드를 생성하며 default value로 초기화하는 작업을 수행한다. **주의할 점은, 이 단계에서 static code가 실행되는 것은 아니다.** 코드 실행은 Initialization 단계에서 수행된다. 

다음 예제는 Prepare 절차에서 수행하는 것을 이해하기 위한 예제이다.

```java
public class Main {
    public static void main(String[] args){
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();

        // 하위 클래스 메모리 적재
        classLoader.loadClass("org.example.SubTestClass");
        System.out.println("SubClass is loaded");

        // 하위 클래스의 상위 클래스가 메모리에 적재되었는지 확인
        Method m = ClassLoader.class.getDeclaredMethod("findLoadedClass", new Class[]{String.class});
        m.setAccessible(true);
        Class isFound = (Class) m.invoke(classLoader, "org.example.TestClass");
        System.out.println("SuperClass's Class class : " + isFound);
    }
}

public class SubTestClass extends TestClass{
    static {
        System.out.println("SubTestClass's static block is executed");
    }
}

public class TestClass{
    static {
        System.out.println("TestClass's static block is executed");
    }
}
```

```markup
// 결과
> Task :Main.main()
SubClass is loaded
SuperClass's Class class : class org.example.TestClass

BUILD SUCCESSFUL in 403ms
```

하위클래스(SubTestClass)와 상위클래스(TestClass)를 사용하여, 클래스의 인스턴스는 생성하지 않고(초기화하지 않음을 의미함) Method Area에 클래스 파일 적재만 수행하였다.

결과 값을보면, static 블럭은 실행되지 않았지만, TestClass의 Class 클래스는 존재함을 확인할 수 있다. **즉, static 블럭을 수행하는 Initialization 단계는 수행되지 않았지만, Link 단계의 prepare 절차는 수행되었음을 의미한다.**

<br>

### Resolve

Resolution 단계는 이해하기 참 어려웠다(사실 지금도 긴가민가하다). 공식문서에 따르면 **클래스의 심볼링 참조를 run-time constant pool에 적재하고, run-time constant pool에 있는 참조들이 실제로 존재하는지 확인하는 단계라고 한다.**

이 단계는 실행될 수도 있고 아닐 수도 있다. JVM 구현체에 따라서, Lazy 정책을 쓸 경우에는 해당 참조가 실제로 사용될 때 Resolution 단계가 수행되고, Eager 정책을 쓸 경우에는 verify 절차에서 Resolution 절차도 함께 수행된다고 한다.

확인해보니, 자바 버전에 따라서 내용이 달라지는 듯 싶다. Java7에서는 resolve 절차 여부를 loadClass 함수에서 정할 수 있었지만, Java11에서는 애초에 ClassLoader 클래스의 resolveClass는 넘겨받은 클래스 인스턴스가 null값이 아닌지만 확인하고 있다.

필자는 우선,  **클래스의 심볼링 참조를 run-time constant pool에 적재하고, run-time constant pool에 있는 참조들이 실제로 존재하는지 확인하는 단계** 라는 사실만 이해하고 있으려고 한다.

아래 내용은 JVM Spec 11에서 가져온 자료이다.

> For example, **a Java Virtual Machine implementation may choose a "lazy" linkage strategy, where each symbolic reference in a class or interface (other than the symbolic references above) is resolved individually when it is used.** Alternatively, an implementation may choose an "eager" linkage strategy, where all symbolic references are resolved at once when the class or interface is being verified. This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Whichever strategy is followed, any error detected during resolution must be thrown at a point in the program that (directly or indirectly) uses a symbolic reference to the class or interface. - JVM Spec 11
> 

Many Java Virtual Machine instructions - *anewarray*, *checkcast*, *getfield*, *getstatic*, *instanceof*, *invokedynamic*, *invokeinterface*, *invokespecial*, *invokestatic*, *invokevirtual*, *ldc*, *ldc_w*, *ldc2_w*, *multianewarray*, *new*, *putfield*, and *putstatic* - rely on symbolic references in the run-time constant pool. **Execution of any of these instructions requires *resolution* of the symbolic reference.**

**Resolution is the process of dynamically determining one or more concrete values from a symbolic reference in the run-time constant pool.** Initially, all symbolic references in the run-time constant pool are unresolved.

<br><br>

## Initialization

초기화 단계에서는 클래스의 static initializer 가 수행되며 static 필드가 초기화된다. 이때 static block이 실행된다. 특정 클래스가 초기화 되기 이전에, 해당 클래스의 상위 클래스가 먼저 초기화 되어야 한다. 초기화는 다음의 상황에서 수행된다.

- 특정 클래스의 인스턴스가 생성될 때
- 특정 클래스의 static 메소드가 실행될 때
- 특정 클래스의 static 필드가 assign 될 때
- 특정 클래스의 static 필드가 사용되고, 해당 필드가 constant 변수가 아닐 때
- 특정 클래스가 nested 클래스가 아니고, 해당 클래스 내에서 assert 문이 실행되었을 때
- Class 클래스에 의한 reflective 메소드에 의해 사용될 때

다른 상황에서는 클래스 초기화가 수행되지 않는다.(Class 클래스의 인스턴스 초기화를 말하는 것임)

다음은 “상위클래스는 하위클래스 이전에 초기화된다.”와 관련한 예제이다.

```java
class Super {
    static { System.out.print("Super "); }
}
class One {
    static { System.out.print("One "); }
}
class Two extends Super {
    static { System.out.print("Two "); }
}
class Test {
    public static void main(String[] args) {
        One o = null;
        Two t = new Two();
        System.out.println((Object)o == (Object)t);
    }
}
```

```java
// 결과
Super Two false
```

One 클래스는 직접적으로 사용되지 않기 때문에 초기화 되지 않는다. 따라서, One 클래스의 static 블럭을 실행되지 않는다.

Two 클래스의 생성시 상위 클래스인 Super 클래스가 먼저 초기화되고, 이후 Two 클래스가 초기화된다.

<br>

### 초기화 절차

각각의 클래스들은 자신만의 고유한 ‘초기화 락’을 갖는다. 다음은 클래스를 초기화하는 절차이다.

1. 클래스가 보유한 ‘초기화 락’을 잡으려고 시도한다. 현재 쓰레드가 락을 잡을 때까지 기다린다.
2. 만약 다른 쓰레드에서 해당 클래스를 Initialization 하고 있다면, 락을 release하고, Initialization을 수행중인 다른 쓰레드가 완료할 때까지 현재 쓰레드는 블락된다.
3. 만약 현재 쓰레드가 해당 클래스를 Initialization 하고 있다면, 락을 release한다.
4. 만약 클래스가 이미 초기화된 상태라면, 락을 release한다.
5. 만약 클래스가 error 상태라면, 초기화는 불가능하다. 락을 release하고 ‘NoClassDefFoundError’를 throw한다.
6. error 상태가 아니라면, 해당 클래스에 대한 초기화가 현재 쓰레드에 의해 진행 중임을 기록하고, 락을 release한다. 이후, final 타입의 클래스 변수 및 필드들을 초기화한다.
7. 클래스의 상위클래스가 아직 초기화 되지 않은 상태라면, 재귀적으로 앞선 절차들을 상위클래스에 대해 수행한다. 만약 상위클래스 초기화중 Exception에 의해 종료된다면, 현재 (하위)클래스의 락을 요청하고, 클래스의 상태를 error상태로 바꾸고, 대기중인 쓰레드들에게 notify하고, 초기화 락을 relelase한 이후, 상위 클래스에서 throw한 Exception을 동일하게 throw한다.
8. 이후, 클래스 변수 초기화와 클래스에 대한 static 초기화를 수행한다. 초기화가 정상적으로 완료되면 해당 클래스가 완전히 초기화 되었음을 기록하고, 대기중인 쓰레드들에게 notify하고, 초기화 절차를 종료한다.

위 절차는 자바 문서를 바탕으로 작성하였지만, 필자가 아직 lock에 대한 이해도가 낮아 제대로 작성하지 못하였다. 추후 수정이 필요해 보인다. 참고한 자료는 아래와 같다.

[Chapter 12. Execution](https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2)


<br><br><br>

## 자바 프로그램의 시작이 “public static void main(String[])” 에서 시작하는 이유는 무엇일까?

답변 : 다양한 답변이 존재했다.

- OOP기반 언어이기 때문에 프로그램의 시작 entry인 main함수는 static으로 해야한다.
- C, C++ 친화적이게 만든 것
- 고정해두어야 java.exe에서 실행하기 편하기 때문에

이유를 덧붙이자면, 자바는 OOP이기 때문에 object를 기반으로 동작한다. 따라서 프로그램의 시작인 main method는 static으로 만든 것이라고 보인다. 내용을 찾아보니, 사람들도 잘 모르는 것 같다. 심지어, Java 21부터는 기존(public, static, String[]) 문법 없이도 main 메소드를 정의할 수 있게 해놓았다.

[Why is the Java main method static?](https://stackoverflow.com/questions/146576/why-is-the-java-main-method-static)