## java에서 volatile 키워드의 의미는?

답변 : 변수의 값에 수정이 있을 경우 메인 메모리에 즉각 저장하도록 한다. 또한, 해당 변수의 값이 변경되었을 경우 다른 쓰레드들이 이를 알 수 있도록 한다.

다중 쓰레드들이 코드블럭을 병렬적으로 실행하는 것은 괜찮지만, 반드시 쓰레드들 간의 가시성을 확보해야될 때 유용하게 사용된다. 예를 들어, A라는 쓰레드는 volatile 변수의 값을 수정하고, B라는 쓰레드는 해당 값을 Read만 할 경우, A & B 쓰레드 간의 가시성을 확보할수 있다.

반면, A & B 쓰레드가 counter++ 와 같은 변수값을 수정하는 동작을 둘다 수행한다면, increment 연산이 시스템적으로 one at once하게 동작하지 않기 때문에,synchronized하지 않을 수 있다. 

volatile 키워드를 붙이면 다음과 같은 효과를 준다.

- 변수의 값 수정에 대한 가시성
- 최적화를 위한 명령어 재배치 금지
- volatile 변수 수정 시, 쓰레드에게 보여지는 모든 변수 값들을 함께 메모리에 저장

그렇다면, JVM에서는 어떻게 volatile을 구현했을까?

1. 컴파일러와 런타임이 volatile 변수를 레지스터에 저장하는 것을 금지
2. 컴파일러와 옵티마이저가 code를 재배치하는 것을 비허용
3. 컴파일러와 런타임에게 volatile 변수가 수정될 경우 곧바로 메인 메모리에 저장하도록 강제
4. volatile 변수에 대해서 cache에 저장되있지 않다고 마킹해둠.

[Java Volatile Keyword](https://jenkov.com/tutorials/java-concurrency/volatile.html)

[Guide to the Volatile Keyword in Java | Baeldung](https://www.baeldung.com/java-volatile)

[](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile)


<br><br>

## Bufferd***에서 buf[]가 volatile 변수인 이유는?

답변 : 멀티스레드 환경에서도 정상적으로 작동하기 위함이다.

실행 도중, buf 변수에 다른 배열이 할당될 수 있으며, 이를 모든 스레드가 알 수있게 하기 위함이다. buf 이외에도 InputStream을 담은 in변수도 volatile로 지정되있다.(FilterInputStream에서)

<br><br>
## Buffer를 사용하는 이유는? 

답변 : 입력 or 출력 값에 대해 버퍼에 저장한 이후, 시스템콜을 호출하여 한꺼번에 처리함으로써 시스템콜을 자주 호출하는 것에 대한 비효율을 줄여준다. 다만, 상대적으로 작은 양의 데이터를 여러번 다룰 때 효과적이며, 시스템콜의 명령어(ex. flush - 4KB)에서 사용하는 데이터 사이즈 하고 유사할 때 효과적이다.

[Usage of BufferedInputStream](https://stackoverflow.com/questions/3122422/usage-of-bufferedinputstream)