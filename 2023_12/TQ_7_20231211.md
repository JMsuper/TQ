## 해시 알고리즘이란?
### Components of Hashing

1. Key : 해시 함수에 입력값으로 들어가는 문자열 혹은 정수를 의미한다. Key를 통해 해시 테이블의 인덱스 값이나 위치를 알 수 있다.
2. Hash Function : 입력 key 값을 받아 해시 테이블의 인덱스 값을 반환하는 함수이다.
3. Hash Table : key-value 형태의 자료구조 이며, 해시 함수를 통해 해시 인덱스를 구성한다.

### What is Hash functions?

해시 함수는 수학적인 연산을 통해서, key와 value 사이의 매핑을 만든다. 해시 함수의 결과는 hash value 또는 해시라고 불려진다. hash value는 원래의 문자열을 대표하지만, 일반적으로 원본보다는 길이가 짧다.

해시 함수의 종류

1. Division Method
    
    해시값을 만들기 위한 가장 간다하고 쉬운 방법이다. K를 M으로 나눈 나머지를 해시값으로 사용한다. 해시 테이블의 엔트리에 대해 고르게 분포하도록 M을 소수로 지정하는 것이 효과적이다.
    
    ```markdown
    h(K) = k mod M
    k : the key value
    M : the size of the hash table
    ```
    
    - 장점 : 어떠한 M 값이라도 동작한다. 하나의 나누기 연산만 수행하기 때문에 매우 빠르다.
    - 단점 : 연속된 key 값은 연속된 해시값으로 매핑되기 때문에 성능상 좋지 않다(? 이해가 안됨). M의 값을 선정하는데 주의가 필요하다.
2. Mid Square Method
    
    **계산방법**
    
    1. Key 값을 제곱
    2. 가운데 r 자리를 해시값으로 추출
    
    ```markdown
    k = 60 , r = 2
    k x k = 3600
    h(60) = 60
    ```
    
    r의 값은 테이블의 크기에 기반하여 결정한다.
    
    - 장점 : Key 값에 포함된 모든 숫자가 result를 만드는데 기여하므로 성능이 좋다. 원래 Key 값의 상위 혹은 하위 숫자에 의해 value값이 좌우되지 않는다.
    - 단점 : Key 값의 크기가 이 방법의 제약사항이다. Key 값이 크다면 result를 추출하기 위한 Key^2은 Key의 자릿수에 두 배가 될 것이다.
3. Digit Folding Method
    
    **계산방법**
    
    1. Key 값의 숫자들을 숫자 묶음으로 분리(12345 → 12, 34, 5)
    2. 분리된 숫자 묶음을 전부 더하기(12 + 34 + 5 = 51)
    
    ```markdown
    k = 12345
    k1 = 12, k2 = 34, k3 = 5
    s = k1 + k2 + k3 = 51
    h(k) = 51
    ```
    
    각 부분의 자릿수는 해시 테이블의 크기에 따라 달라진다.
    
4. Multiplication Method
    
    **계산방법**
    
    1. 0 < A < 1 의 숫자를 지정
    2. Key값에 A를 곱함
    3. kA의 소숫점 아래 숫자만 남김
    4. 추출한 수숫점 아래 숫자를 해시 테이블의 크기(M)으로 곱함
    5. 4의 결과값을 반올림
    
    ```markdown
    k = 12345
    A = 0.357840
    M = 100
    
    h(12345) = floor[ 100 (12345*0.357840 mod 1)]
                   = floor[ 100 (4417.5348 mod 1) ]
                   = floor[ 100 (0.5348) ]
                   = floor[ 53.48 ]
                   = 53
    ```
    
    - 특징 : 해시 테이블의 사이즈가 2의 거듭제곱일 떄 효과적이다.

### Properties of a Good hash function

모든 item을 각각의 고유한 슬롯으로 매핑하는 해시 함수에 대해 완벽한 해시 함수라고 지칭한다. 만약 item들과 해당 요소들이 변경되지 않는다면 완벽한 해시 함수를 만들 수 있을 것이다. 하지만, 임의의 요소들에 대한 완벽한 해시 함수를 만드는 것은 시스템적으로 불가능하다.

따라서, 해시 함수를 만든 때 아래 사항을 유의해야 한다.

1. 효율적 계산가능
2. Key값이 테이블에 균등하개 배분되어야 함
3. 충돌을 최소화
4. 부하율(테이블의 항목 수를 테이블 크기로 나눈 값)이 낮아야 함

## Problem with Hahsing

해싱 프로세스는 Key값보다 더 작은 크기를 가진 해시값을 생성하기 때문에, 서로 다른 두개의 Key가 같은 해시값을 생성할 수도 있다. 이 경우 충돌이 발생한다.

![Alt text](images/image.png)

## How to handle Collisions?

해시 충돌을 다루는 방법은 크게 Seprate Chaining(Open Hashing)과 Open Addressing(Closed Hashing)으로 나뉜다.

![Alt text](image-1.png)

### 1. Separate Chaining

해시 테이블의 각 셀을 연결 리스트로 만드는 방법이다. 같은 해시값을 갖는 경우, 해시 인덱스에 위치한 슬롯에 있는 연결 리스트에 추가될 것이다. 체이닝은 간단하지만, 해시 테이블 외부의 추가적인 메모리 공간을 요구한다.

![Alt text](image-2.png)

### 2. Open Addressing

Open Addressing 방식에서, 추가적인 메모리 공간할당 없이 모든 요소들이 해시 테이블에 저장된다. 

### 2.a) Linear Probing

선형 탐색 방식에서, 해시 테이블에 대해 Key 값으로 도출한 해시값의 위치가 이미 사용중일 경우, 해시 테이블의 다음 인덱스를 탐색한다. 만약 다음 인덱스에 자리가 있으면, 그 곳에 해시값을 할당한다. 

```markdown
1. hash 값을 계산. EX) key = data % size
2. hashTable[key]가 비어있는지 확인하고, 비어있으며 그곳에 data를 할당
3. 만약 해시 인덱스가 이미 사용중이라면, key = (key + 1) % size를 수행하여 다시 탐색한다.
4. 다음 인덱스가 사용가능하다면 할당하고, 아니라면 다시 반복한다.
5. 적절한 공간을 찾을 때까지 반복한다.
EX> data % 5
```

![Alt text](image-3.png)

### 2.b) Quadratic Probing

해시 테이블의 비어있는 slot을 찾기 위해, 원래의 해시 인덱스 값에 임의의 2차 다항식의 연속 값을 추가한다. 예를 들어 H 라는 해시 인덱스가 이미 사용중이면, H + 1^2 에 해당하는 인덱스를 확인하고, 이후 H + 2^2 … H + 3^2 형식으로 탐색을 수행한다.

```markdown
만약 hash(x) % n의 slot이 사용중이면, (hash(x) + 1^2) & n 을 수행하다.
만약 (hash(x) + 1^2) & n의 slot이 사용중이면, (hash(x) + 2^2) & n 을 수행하다.
만약 (hash(x) + 2^2) & n의 slot이 사용중이면, (hash(x) + 3^2) & n 을 수행하다.
비어있는 slot을 찾을 때까지 위 방식을 반복한다.
```

![Alt text](image-4.png)
### 2.c) Double hashing

두 가지의 해시 함수를 사용한다. 첫번째는 기본 해시 함수이고, 두번째는 첫번쨰 해시 함수를 통해 얻어낸 해시값의 이미 사용중일 떄 사용하는 함수이다.

```markdown
h(k, i) = (h1(k) + i * h2(k)) % n
- i : 충돌 횟수
- k : Key 값
- n : 해시 테이블 크기
```


<br><br><br>

## Collection 클래스의 Stream은 무엇인가?
## Stream Operations

Stream이란 무엇일까? 어떤 순서로 나열된 데이터에 적용되는 함수의 집합을 추상화 한 것이다. Stream에서 동작하는 다양한 메서드들이 존재하며, **intermediate operations**와 **terminal operations**로 나눠진다. 

intermediate operations는 Stream<T>을 반환한다. 원본 데이터를 변경하지 않고, 새로운 Stream을 반환하는 것이며, 이를 통해 chaining을 가능케한다.

terminal operations는 정의된 타입의 데이터를 반환하다.

### Iterating

for문, for-each문, while문을 대체하기 위한 함수. 함수의 로직에만 집중하도록 도와준다.

```java
// stream 사용전
boolean isExist(){
		List<String> list = Arrays.asList("Aa","Bb","Cc");
    for(String string : list){
        if(string.contains("b")){
            return true;
        }
    }
}

// stream 사용후
boolean isExist = list.stream().anyMatch(element -> element.contains("b")); 
```

### Filtering

주어진 조건을 만족하는 element를 pick 하도록 도와준다. filter() 메소드는 Predicate 인터페이스의 구현체를 넘겨받는다. Predicate는 boolean type을 반환해야 한다.

```java
List<String> strings = Arrays.asList("Hello", "Hi", "안녕하세요");
List<String> results = strings.stream().filter(string -> string.contains("H"))
															.collect(Collectors.toList());
for (String string: results) {
    System.out.println(string);
}

// Hello
// Hi
```

### Mapping

Stream에 담긴 element들을 특정 함수를 적용한 새로운 element로 변환한다. 변환이후 생성된 element들을 수집하여 Stream에 넣어 반환한다. map() 메서드.

```java
List<String> strings = Arrays.asList("Hello", "Hi", "안녕하세요");
strings.stream().map(string -> string.concat("~!"))
								.forEach(System.out::println);
// Hello~!
// Hi~!
// 안녕하세요~!
```

### Matching

element들을 확인하는 매서드들을 제공한다. anymatch(), allMatch(), noneMatch() 가 있다. 세 메서드 모두 boolean 값을 반환하는 external operation이다.

```java
List<String> strings = Arrays.asList("Hello", "Hi", "안녕하세요");

boolean isValid = strings.stream().anyMatch(e -> e.contains("H")); // true
boolean isValid2 = strings.stream().allMatch(e -> e.contains("H")); // false
boolean isValid3 = strings.stream().noneMatch(e -> e.contains("H")); // false
```

만약 비어있는 stream에 대해 allMatch() 메서드를 실행할 경우 항상 true를 반환하고, anyMatch() 메서드를 실행할 경우 false를 반환한다.

```java
boolean emptyStreamAllMatch = Stream.empty().allMatch(Objects::nonNull); // true
boolean emptyStreamAnyMatch = Stream.empty().anyMatch(Objects::nonNull); // false
```

### Reduction

reduce() 메서드를 통해 누적 연산이 가능하다. 이 메서드는 start value와 accumulator function을 인자로 받는다.

```java
List<String> strings = Arrays.asList("Hello", "Hi", "안녕하세요");
String reducedString = strings.stream().reduce("",(a,b) -> a.concat(b));
System.out.println(reducedString);

// HelloHi안녕하세요
```

[Introduction to Java Streams | Baeldung](https://www.baeldung.com/java-8-streams-introduction)

[Java Stream Filter with Lambda Expression | Baeldung](https://www.baeldung.com/java-stream-filter-lambda)


<br><br><br>

## java에서 time을 다루는 클래스는 어떤 것이 있으며, 어떤 차이가 있을까?

java에서 date와 time을 다루는 패키지는 java.util, java.sql, java.time 이 있다. 자바에는 두 가지 타입의 Date/Time API가 있으며, 하나는 오래된 API이고 하나는 Java 8에서 추가된 신규 API이다. 신규 API는 java.time 패키지에 담겨있으며, Java에서는 신규 API를 사용하도록 권장하고 있다. 

### 과거의 사용된 Date/Time API

위 API가 처음 도입되었을 때 java.util 패키지에 담겨졌다. 해당 API는 “Date” 클래스 이며, 실제 Date를 특정한 규격으로 나타내기 위한 용도로 사용됬다. 과거 API는 몇몇 문제를 야기했으며, 신규 Date API는 이를 적절하게 대응했다. 과거API의 문제점을 살펴보자.

- 만약 Date 클래스의 인스턴스를 생성하고자 한다면, java.sql & java.util 중에서 선택해야 한다. java.sql은 데이터베이스에 맞는 데이터 규격을 제공하기 위함이고, java.util은 java 언어에 적합한 규격을 제공한다.
- 또한, date의 몇몇 포멧을 사용하고자 한다면 java.text 패키지를 import 해야한다.
- 위에서 언급한 Date/Time 클래스들은 thread-safety하지 않다.
- Zoned date를 사용하는 것이 어렵다.

### 신규(Java8) Date/Time API

신규 API는 “date” , “time” , “instant” , “time-zone”과 같은 표준화된 시간 컨셉을 제공한다. 주요한 특징은 **모든 클래스는 immutable하며, thread-safety 하다**는 것이다. 주로 사용되는 API는 다음과 같다.

- LocalDate : (year, month, day(yyyy-MM-dd))와 같은 date를 다룬다.
- LocalTime : (hour, minute, second and nanoseconds (HH-mm-ss-ns))와 같은 time을 다룬다.
- LocalDateTime : 위의 date & time을 함께 다룬다.(yyyy-MM-dd-hh-mm-ss-ns)
- DateTimeFormatter : date-time 개체를 파싱하고 보여주기위한 포멧팅을 지원한다.

```java
LocalDate now = LocalDate.now();
LocalDate sampleDate = LocalDate.of(2000,01,01);
LocalDate stringDate = LocalDate.parse("2000-01-01");

LocalTime nowTime = LocalTime.now();

LocalDateTime nowDateAndTime = LocalDateTime.now();
```

[Understanding Date and Time In Java](https://medium.com/nerd-for-tech/understanding-date-and-time-in-java-140221a24944)

[Introduction to the Java 8 Date/Time API | Baeldung](https://www.baeldung.com/java-8-date-time-intro)


<br><br><br>

## HashSet과 ArrayList 의 연산 성능 비교하면?

답변 : HashSet은 모든 연산에 대해 O(1) 을 지원하지만, element의 순서를 보장하지 않음. ArrayList는 element의 순서를 보장하지만, O(1) or O(n) 으로 동작

<br><br><br>

## String vs StringBuilder vs StringBuffer?

String은 char의 연속된 나열이다. java에서 String 클래스의 인스턴스는 불변한 객체이기 때문에 수정이 불가하다. 이러한 특징을 보완하기 위해 StringBuffer or StringBuilder를 함께 사용한다.

```java
void concat1(String s1,String s2){
        s1 = s1 + s2;
}

void concat2(StringBuilder sb1, String s2){
        sb1.append(s2);
}

void concat3(StringBuffer sb2, String s2){
    sb2.append(s2);
}
    
void test(){
    String hello = "hello";
    String world = "world";

    concat1(hello,world);
    System.out.println(hello); // hello

    StringBuilder stringBuilder = new StringBuilder("hello");
    concat2(stringBuilder,world);
    System.out.println(stringBuilder); // helloworld

    StringBuffer stringBuffer = new StringBuffer("hello");
    concat3(stringBuffer,world);
    System.out.println(stringBuffer); // helloworld
}
```

- concat1 : “hello”라는 String 클래스의 인스턴스를 인자로 넘겨주었으며, 해당 인자와 “world”를 더하는 연산을 수행하고, 결과값을 인자값에 재할당하였다. 하지만, hello 변수는 변하지 않았다. 메서드의 인자로 넘겨준 것은 immutable하기 때문에, String + String 연산으로 생성된 값은 새로운 인스턴스이며, “hello” String 래퍼런스와는 다른 것이다.
- concat2, concat3 : StringBuilder와 StringBuffeer는 mutable하기 때문에 가지고 있는 String 값이 변경되었다.

String의 값을 변경해야될 경우 String이 아닌 StringBuilder와 StringBuffer를 사용하면 된다.

### StringBuffer vs StringBuilder

위 클래스 중 먼저 나온 것은 StringBuffer이다. Java 1.4까지는 StringBuffer가 사용되었지만, public 멤버 메서드가 synchronized하게 구현되어 있어(StringBuffer는 Thread-safety함) 낮은 성능을 갖는다는 단점을 보완하기 위해, Java 1.5에 StringBuilder가 추가되었다.

만약 싱글 쓰레드 환경에서 사용하거나 thread-safety기능이 불필요할 경우 StringBuilder가 적합하다. 그 외에 Thread-safety가 필요하다면, StringBuffer가 적합하다.

- 성능 비교
    
    ```java
    void test(){
            System.gc();
            long start = System.currentTimeMillis();
            long startMemory = Runtime.getRuntime().freeMemory();
    
    //        StringBuffer sb = new StringBuffer();
            StringBuilder sb = new StringBuilder();
    
            for (int i = 0; i < 1000000; i++) sb.append(":").append(i);
            long end = System.currentTimeMillis();
            long endMemory = Runtime.getRuntime().freeMemory();
            System.out.println("Time taken: " + (end-start));
            System.out.println("Memory Used: " + (startMemory-endMemory));
    }
    ```
    
    |  | Time | Memory |
    | --- | --- | --- |
    | StringBuffer | 47 | 37,636,144 |
    | StringBuilder | 36 | 37,636,144 |
    
    메모리 사용량은 동일하지만, StringBuilder가 StringBuffer보다 더 빠르다는 것을 확인하였다.(싱글 쓰레드 환경)
    

### 사용 팁

- 프로그램 전역에서 “문자열”이 constant하게 사용될 경우, String 클래스를 사용하여 immutable한 객체를 사용한다.
- “문자열”이 수정될 수 있고, 싱글 쓰레드 환경에서 접근된 다면, StringBuilder를 사용한다.
- “문자열”이 수정될 수 있고, 멀티 쓰레드 환경에서 접근된 다면, StringBuffer를 사용한다.

[String vs StringBuilder vs StringBuffer in Java - GeeksforGeeks](https://www.geeksforgeeks.org/string-vs-stringbuilder-vs-stringbuffer-in-java/)

[String vs StringBuffer vs StringBuilder  | DigitalOcean](https://www.digitalocean.com/community/tutorials/string-vs-stringbuffer-vs-stringbuilder)

<br><br><br>

## java의 HashMap은 어떻게 동작할까?

**답변 : JAVA8 기준으로, 해시 충돌을 위해 seperate chaining을 사용한다. 추가적으로, 일정 threshold를 넘어가면 lisked list를 balanced tree로 전환한다.**

HashMap은 내부적으로 Array<Node> 자료형을 갖는다. Array는 element가 담길 bucket을 의미하고, Node클래스의 인스턴스는는 다음 Node의 래퍼런스를 갖으며, seperate chaining을 지원하기 위한 자료형이다.

![Alt text](image-5.png)

[Internal Working of HashMap in Java.](https://prateeknima.medium.com/internal-working-of-hashmap-in-java-e5b67890e152)

[JEP 180: Handle Frequent HashMap Collisions with Balanced Trees](https://openjdk.org/jeps/180)


<br><br><br>

## floating point 연산은 무엇인가?

### 고정 소수점(fixed point) 방식

실수는 보통 정수부와 소수부로 나눠짐

따라서 실수를 표현하는 가장 간단한 방법은 소수부의 자릿수를 미리 정하여, 고정된 자릿수의 소수를 표현하는 것이다. 하지만, 정수부와 소수부의 자릿수가 크지 않으므로, 표현할 수 있는 범위가 매우 적다는 단점이 있다.

![Alt text](image-6.png)

### 부동 소수점(floating point) 방식

실수는 **가수부**와 **지수부**로 나누어 표현할 수도 있다.

<aside>
💡 (1.가수부) x 2^(지수부 - 127)

</aside>

- 32비트의 float형 실수(IEEE 754 표준)
    
    ![Alt text](image-7.png)
    
- 64비트의 double형 실수(IEEE 754 표준)
    
    ![Alt text](image-8.png)
